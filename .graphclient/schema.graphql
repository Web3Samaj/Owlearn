schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Certificate {
  id: Bytes!
  course: Course!
  certificateAddress: Bytes!
  certificateBaseURI: String
  certificateName: String
  certificateSymbol: String
  enrolledUsers(skip: Int = 0, first: Int = 100, orderBy: User_orderBy, orderDirection: OrderDirection, where: User_filter): [User!]
}

input Certificate_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  course: String
  course_not: String
  course_gt: String
  course_lt: String
  course_gte: String
  course_lte: String
  course_in: [String!]
  course_not_in: [String!]
  course_contains: String
  course_contains_nocase: String
  course_not_contains: String
  course_not_contains_nocase: String
  course_starts_with: String
  course_starts_with_nocase: String
  course_not_starts_with: String
  course_not_starts_with_nocase: String
  course_ends_with: String
  course_ends_with_nocase: String
  course_not_ends_with: String
  course_not_ends_with_nocase: String
  course_: Course_filter
  certificateAddress: Bytes
  certificateAddress_not: Bytes
  certificateAddress_gt: Bytes
  certificateAddress_lt: Bytes
  certificateAddress_gte: Bytes
  certificateAddress_lte: Bytes
  certificateAddress_in: [Bytes!]
  certificateAddress_not_in: [Bytes!]
  certificateAddress_contains: Bytes
  certificateAddress_not_contains: Bytes
  certificateBaseURI: String
  certificateBaseURI_not: String
  certificateBaseURI_gt: String
  certificateBaseURI_lt: String
  certificateBaseURI_gte: String
  certificateBaseURI_lte: String
  certificateBaseURI_in: [String!]
  certificateBaseURI_not_in: [String!]
  certificateBaseURI_contains: String
  certificateBaseURI_contains_nocase: String
  certificateBaseURI_not_contains: String
  certificateBaseURI_not_contains_nocase: String
  certificateBaseURI_starts_with: String
  certificateBaseURI_starts_with_nocase: String
  certificateBaseURI_not_starts_with: String
  certificateBaseURI_not_starts_with_nocase: String
  certificateBaseURI_ends_with: String
  certificateBaseURI_ends_with_nocase: String
  certificateBaseURI_not_ends_with: String
  certificateBaseURI_not_ends_with_nocase: String
  certificateName: String
  certificateName_not: String
  certificateName_gt: String
  certificateName_lt: String
  certificateName_gte: String
  certificateName_lte: String
  certificateName_in: [String!]
  certificateName_not_in: [String!]
  certificateName_contains: String
  certificateName_contains_nocase: String
  certificateName_not_contains: String
  certificateName_not_contains_nocase: String
  certificateName_starts_with: String
  certificateName_starts_with_nocase: String
  certificateName_not_starts_with: String
  certificateName_not_starts_with_nocase: String
  certificateName_ends_with: String
  certificateName_ends_with_nocase: String
  certificateName_not_ends_with: String
  certificateName_not_ends_with_nocase: String
  certificateSymbol: String
  certificateSymbol_not: String
  certificateSymbol_gt: String
  certificateSymbol_lt: String
  certificateSymbol_gte: String
  certificateSymbol_lte: String
  certificateSymbol_in: [String!]
  certificateSymbol_not_in: [String!]
  certificateSymbol_contains: String
  certificateSymbol_contains_nocase: String
  certificateSymbol_not_contains: String
  certificateSymbol_not_contains_nocase: String
  certificateSymbol_starts_with: String
  certificateSymbol_starts_with_nocase: String
  certificateSymbol_not_starts_with: String
  certificateSymbol_not_starts_with_nocase: String
  certificateSymbol_ends_with: String
  certificateSymbol_ends_with_nocase: String
  certificateSymbol_not_ends_with: String
  certificateSymbol_not_ends_with_nocase: String
  enrolledUsers: [String!]
  enrolledUsers_not: [String!]
  enrolledUsers_contains: [String!]
  enrolledUsers_contains_nocase: [String!]
  enrolledUsers_not_contains: [String!]
  enrolledUsers_not_contains_nocase: [String!]
  enrolledUsers_: User_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Certificate_filter]
  or: [Certificate_filter]
}

enum Certificate_orderBy {
  id
  course
  course__id
  course__creatorId
  course__courseId
  course__address
  course__name
  course__symbol
  course__courseURI
  course__resourceAddress
  course__certificateAddress
  course__mintModule
  certificateAddress
  certificateBaseURI
  certificateName
  certificateSymbol
  enrolledUsers
}

type Course {
  id: Bytes!
  creatorId: BigInt!
  courseId: BigInt!
  address: Bytes!
  name: String!
  symbol: String!
  courseURI: String!
  resourceAddress: Bytes
  certificateAddress: Bytes
  resources(skip: Int = 0, first: Int = 100, orderBy: Resource_orderBy, orderDirection: OrderDirection, where: Resource_filter): [Resource!]
  educator: Educator!
  certificate: Certificate
  mintModule: Bytes
}

input Course_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  creatorId: BigInt
  creatorId_not: BigInt
  creatorId_gt: BigInt
  creatorId_lt: BigInt
  creatorId_gte: BigInt
  creatorId_lte: BigInt
  creatorId_in: [BigInt!]
  creatorId_not_in: [BigInt!]
  courseId: BigInt
  courseId_not: BigInt
  courseId_gt: BigInt
  courseId_lt: BigInt
  courseId_gte: BigInt
  courseId_lte: BigInt
  courseId_in: [BigInt!]
  courseId_not_in: [BigInt!]
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  courseURI: String
  courseURI_not: String
  courseURI_gt: String
  courseURI_lt: String
  courseURI_gte: String
  courseURI_lte: String
  courseURI_in: [String!]
  courseURI_not_in: [String!]
  courseURI_contains: String
  courseURI_contains_nocase: String
  courseURI_not_contains: String
  courseURI_not_contains_nocase: String
  courseURI_starts_with: String
  courseURI_starts_with_nocase: String
  courseURI_not_starts_with: String
  courseURI_not_starts_with_nocase: String
  courseURI_ends_with: String
  courseURI_ends_with_nocase: String
  courseURI_not_ends_with: String
  courseURI_not_ends_with_nocase: String
  resourceAddress: Bytes
  resourceAddress_not: Bytes
  resourceAddress_gt: Bytes
  resourceAddress_lt: Bytes
  resourceAddress_gte: Bytes
  resourceAddress_lte: Bytes
  resourceAddress_in: [Bytes!]
  resourceAddress_not_in: [Bytes!]
  resourceAddress_contains: Bytes
  resourceAddress_not_contains: Bytes
  certificateAddress: Bytes
  certificateAddress_not: Bytes
  certificateAddress_gt: Bytes
  certificateAddress_lt: Bytes
  certificateAddress_gte: Bytes
  certificateAddress_lte: Bytes
  certificateAddress_in: [Bytes!]
  certificateAddress_not_in: [Bytes!]
  certificateAddress_contains: Bytes
  certificateAddress_not_contains: Bytes
  resources_: Resource_filter
  educator: String
  educator_not: String
  educator_gt: String
  educator_lt: String
  educator_gte: String
  educator_lte: String
  educator_in: [String!]
  educator_not_in: [String!]
  educator_contains: String
  educator_contains_nocase: String
  educator_not_contains: String
  educator_not_contains_nocase: String
  educator_starts_with: String
  educator_starts_with_nocase: String
  educator_not_starts_with: String
  educator_not_starts_with_nocase: String
  educator_ends_with: String
  educator_ends_with_nocase: String
  educator_not_ends_with: String
  educator_not_ends_with_nocase: String
  educator_: Educator_filter
  certificate: String
  certificate_not: String
  certificate_gt: String
  certificate_lt: String
  certificate_gte: String
  certificate_lte: String
  certificate_in: [String!]
  certificate_not_in: [String!]
  certificate_contains: String
  certificate_contains_nocase: String
  certificate_not_contains: String
  certificate_not_contains_nocase: String
  certificate_starts_with: String
  certificate_starts_with_nocase: String
  certificate_not_starts_with: String
  certificate_not_starts_with_nocase: String
  certificate_ends_with: String
  certificate_ends_with_nocase: String
  certificate_not_ends_with: String
  certificate_not_ends_with_nocase: String
  certificate_: Certificate_filter
  mintModule: Bytes
  mintModule_not: Bytes
  mintModule_gt: Bytes
  mintModule_lt: Bytes
  mintModule_gte: Bytes
  mintModule_lte: Bytes
  mintModule_in: [Bytes!]
  mintModule_not_in: [Bytes!]
  mintModule_contains: Bytes
  mintModule_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Course_filter]
  or: [Course_filter]
}

enum Course_orderBy {
  id
  creatorId
  courseId
  address
  name
  symbol
  courseURI
  resourceAddress
  certificateAddress
  resources
  educator
  educator__id
  educator__address
  educator__educatorId
  educator__username
  certificate
  certificate__id
  certificate__certificateAddress
  certificate__certificateBaseURI
  certificate__certificateName
  certificate__certificateSymbol
  mintModule
}

type Educator {
  id: Bytes!
  address: Bytes!
  educatorId: BigInt
  username: String
  courses(skip: Int = 0, first: Int = 100, orderBy: Course_orderBy, orderDirection: OrderDirection, where: Course_filter): [Course!]
}

input Educator_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  educatorId: BigInt
  educatorId_not: BigInt
  educatorId_gt: BigInt
  educatorId_lt: BigInt
  educatorId_gte: BigInt
  educatorId_lte: BigInt
  educatorId_in: [BigInt!]
  educatorId_not_in: [BigInt!]
  username: String
  username_not: String
  username_gt: String
  username_lt: String
  username_gte: String
  username_lte: String
  username_in: [String!]
  username_not_in: [String!]
  username_contains: String
  username_contains_nocase: String
  username_not_contains: String
  username_not_contains_nocase: String
  username_starts_with: String
  username_starts_with_nocase: String
  username_not_starts_with: String
  username_not_starts_with_nocase: String
  username_ends_with: String
  username_ends_with_nocase: String
  username_not_ends_with: String
  username_not_ends_with_nocase: String
  courses_: Course_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Educator_filter]
  or: [Educator_filter]
}

enum Educator_orderBy {
  id
  address
  educatorId
  username
  courses
}

"""
8 bytes signed integer

"""
scalar Int8

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Query {
  course(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Course
  courses(
    skip: Int = 0
    first: Int = 100
    orderBy: Course_orderBy
    orderDirection: OrderDirection
    where: Course_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Course!]!
  resource(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Resource
  resources(
    skip: Int = 0
    first: Int = 100
    orderBy: Resource_orderBy
    orderDirection: OrderDirection
    where: Resource_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Resource!]!
  certificate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Certificate
  certificates(
    skip: Int = 0
    first: Int = 100
    orderBy: Certificate_orderBy
    orderDirection: OrderDirection
    where: Certificate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Certificate!]!
  educator(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Educator
  educators(
    skip: Int = 0
    first: Int = 100
    orderBy: Educator_orderBy
    orderDirection: OrderDirection
    where: Educator_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Educator!]!
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Resource {
  id: Bytes!
  course: Course!
  resourceURI: String!
  resourceId: BigInt!
}

input Resource_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  course: String
  course_not: String
  course_gt: String
  course_lt: String
  course_gte: String
  course_lte: String
  course_in: [String!]
  course_not_in: [String!]
  course_contains: String
  course_contains_nocase: String
  course_not_contains: String
  course_not_contains_nocase: String
  course_starts_with: String
  course_starts_with_nocase: String
  course_not_starts_with: String
  course_not_starts_with_nocase: String
  course_ends_with: String
  course_ends_with_nocase: String
  course_not_ends_with: String
  course_not_ends_with_nocase: String
  course_: Course_filter
  resourceURI: String
  resourceURI_not: String
  resourceURI_gt: String
  resourceURI_lt: String
  resourceURI_gte: String
  resourceURI_lte: String
  resourceURI_in: [String!]
  resourceURI_not_in: [String!]
  resourceURI_contains: String
  resourceURI_contains_nocase: String
  resourceURI_not_contains: String
  resourceURI_not_contains_nocase: String
  resourceURI_starts_with: String
  resourceURI_starts_with_nocase: String
  resourceURI_not_starts_with: String
  resourceURI_not_starts_with_nocase: String
  resourceURI_ends_with: String
  resourceURI_ends_with_nocase: String
  resourceURI_not_ends_with: String
  resourceURI_not_ends_with_nocase: String
  resourceId: BigInt
  resourceId_not: BigInt
  resourceId_gt: BigInt
  resourceId_lt: BigInt
  resourceId_gte: BigInt
  resourceId_lte: BigInt
  resourceId_in: [BigInt!]
  resourceId_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Resource_filter]
  or: [Resource_filter]
}

enum Resource_orderBy {
  id
  course
  course__id
  course__creatorId
  course__courseId
  course__address
  course__name
  course__symbol
  course__courseURI
  course__resourceAddress
  course__certificateAddress
  course__mintModule
  resourceURI
  resourceId
}

type Subscription {
  course(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Course
  courses(
    skip: Int = 0
    first: Int = 100
    orderBy: Course_orderBy
    orderDirection: OrderDirection
    where: Course_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Course!]!
  resource(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Resource
  resources(
    skip: Int = 0
    first: Int = 100
    orderBy: Resource_orderBy
    orderDirection: OrderDirection
    where: Resource_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Resource!]!
  certificate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Certificate
  certificates(
    skip: Int = 0
    first: Int = 100
    orderBy: Certificate_orderBy
    orderDirection: OrderDirection
    where: Certificate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Certificate!]!
  educator(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Educator
  educators(
    skip: Int = 0
    first: Int = 100
    orderBy: Educator_orderBy
    orderDirection: OrderDirection
    where: Educator_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Educator!]!
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type User {
  id: Bytes!
  address: Bytes!
  owlId: BigInt!
  username: String!
  enrolledCourses(skip: Int = 0, first: Int = 100, orderBy: Course_orderBy, orderDirection: OrderDirection, where: Course_filter): [Course!]
}

input User_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  owlId: BigInt
  owlId_not: BigInt
  owlId_gt: BigInt
  owlId_lt: BigInt
  owlId_gte: BigInt
  owlId_lte: BigInt
  owlId_in: [BigInt!]
  owlId_not_in: [BigInt!]
  username: String
  username_not: String
  username_gt: String
  username_lt: String
  username_gte: String
  username_lte: String
  username_in: [String!]
  username_not_in: [String!]
  username_contains: String
  username_contains_nocase: String
  username_not_contains: String
  username_not_contains_nocase: String
  username_starts_with: String
  username_starts_with_nocase: String
  username_not_starts_with: String
  username_not_starts_with_nocase: String
  username_ends_with: String
  username_ends_with_nocase: String
  username_not_ends_with: String
  username_not_ends_with_nocase: String
  enrolledCourses: [String!]
  enrolledCourses_not: [String!]
  enrolledCourses_contains: [String!]
  enrolledCourses_contains_nocase: [String!]
  enrolledCourses_not_contains: [String!]
  enrolledCourses_not_contains_nocase: [String!]
  enrolledCourses_: Course_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [User_filter]
  or: [User_filter]
}

enum User_orderBy {
  id
  address
  owlId
  username
  enrolledCourses
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}